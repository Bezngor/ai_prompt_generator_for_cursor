name: Build and Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_TAG: latest

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set image name to lowercase
        id: image-name
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "image_name=$IMAGE_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:${{ env.IMAGE_TAG }}
            ${{ env.REGISTRY }}/${{ steps.image-name.outputs.image_name }}:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Set image name to lowercase
        id: image-name
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "image_name=$IMAGE_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: SSH to remote server and deploy
        uses: appleboy/ssh-action@v1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ steps.image-name.outputs.image_name }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: GITHUB_TOKEN,REGISTRY,IMAGE_NAME,IMAGE_TAG,BOT_TOKEN
          script: |
            set -e

            # Login to GHCR on the remote server using GITHUB_TOKEN
            echo "$GITHUB_TOKEN" | docker login $REGISTRY -u "${{ github.actor }}" --password-stdin

            # Find and stop any container using port 8080
            # Method 1: Check all running containers for port 8080
            for CONTAINER_ID in $(docker ps -q); do
              if docker port $CONTAINER_ID 2>/dev/null | grep -q ":8080"; then
                echo "Found container $CONTAINER_ID using port 8080, stopping it..."
                docker stop $CONTAINER_ID || true
                docker rm -f $CONTAINER_ID || true
              fi
            done
            
            # Method 2: Also check by port mapping pattern
            CONTAINER_USING_PORT=$(docker ps --format "{{.ID}}\t{{.Ports}}" | grep -E "0.0.0.0:8080|:::8080|8080->" | cut -f1 | head -1)
            if [ -n "$CONTAINER_USING_PORT" ]; then
              echo "Stopping container using port 8080 (method 2): $CONTAINER_USING_PORT"
              docker stop $CONTAINER_USING_PORT || true
              docker rm -f $CONTAINER_USING_PORT || true
            fi

            # Stop and remove old container by name (force remove)
            if [ "$(docker ps -aq -f name=ai-prompt-generator)" ]; then
              docker stop ai-prompt-generator || true
              docker rm -f ai-prompt-generator || true
            fi

            # Kill any process using port 8080 (if not a Docker container)
            if command -v lsof > /dev/null; then
              lsof -ti:8080 | xargs kill -9 2>/dev/null || true
            elif command -v fuser > /dev/null; then
              fuser -k 8080/tcp 2>/dev/null || true
            fi

            # Wait a moment for port to be released
            sleep 3

            # Verify port is free
            if command -v netstat > /dev/null; then
              if netstat -tuln | grep -q ":8080 "; then
                echo "Warning: Port 8080 is still in use"
                netstat -tuln | grep ":8080 " || true
              fi
            fi

            # Pull latest image
            docker pull $REGISTRY/$IMAGE_NAME:$IMAGE_TAG

            # Run new container
            docker run -d \
              --name ai-prompt-generator \
              --restart unless-stopped \
              -e BOT_TOKEN="$BOT_TOKEN" \
              -p 8080:8080 \
              $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
